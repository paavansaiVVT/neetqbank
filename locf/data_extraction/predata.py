
from locf.data_extraction.classes import file_upload, file_request,courses,academic_years,semesters,Subjects, years_table, Chapters
from sqlalchemy import select, func, text,update
from sqlalchemy.exc import OperationalError
from sqlalchemy.ext.declarative import declarative_base
from dotenv import load_dotenv
from sqlalchemy.orm import sessionmaker
from tenacity import retry, wait_fixed, stop_after_attempt, before_sleep_log
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from locf.data_extraction.helpers import get_file_size
import os, json, logging

load_dotenv()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

DATABASE_URL = os.getenv("DATABASE_URL_8")
engine = create_async_engine(DATABASE_URL,echo=False,pool_size=100,max_overflow=50,pool_recycle=1800, pool_pre_ping=True, connect_args={"connect_timeout": 600})
AsyncSessionLocal = sessionmaker(bind=engine,class_=AsyncSession,expire_on_commit=False)

Base = declarative_base()
retry_on_failure = retry(stop=stop_after_attempt(3),wait=wait_fixed(5),before_sleep=before_sleep_log(logger, logging.WARNING))
def get_session():
    return AsyncSessionLocal()

class PreCourse:
    def __init__(self):
        self.session = get_session()
    """Class to handle pre-course data operations."""
    @retry_on_failure
    async def update_file_data(self,request:file_request,output):
        session = get_session()
        try:
            async with session.begin():
                try:
                    data = file_upload(
                        file_path=request.file_path,
                        file_size=get_file_size(request.file_path),
                        original_filename=request.file_name,
                        program_id=request.program_id,
                        stored_filename=request.file_path,
                        organization_id=request.organization_id,
                        processing_status="Processing",
                        processing_results=output
                    )   
                    session.add(data)
                    await session.flush()  # Flush to get the autogenerated ID
                    file_upload_id =data.id             
                    await session.commit()  # Commit the transaction
                    logger.info(f"File upload data added successfully with ID: {file_upload_id}")
                    return file_upload_id
                except OperationalError as e:
                    logger.error(f"Database operation failed in update_file_data: {e}")                
        finally:
            await session.close()

    async def update_processing_status(self,file_upload_id: int, status: str):
        """Update the processing status of a file_upload entry."""
        session = get_session()
        try:
            async with session.begin():
                await session.execute(
                    update(file_upload)
                    .where(file_upload.id == file_upload_id)
                    .values(processing_status=status)
                )
                await session.commit()
                logger.info(f"Processing status updated to '{status}' for file upload ID {file_upload_id}")
        except Exception as e:
            logger.error(f"Failed to update processing status for ID {file_upload_id}: {e}")
        finally:
            await session.close()




    @retry_on_failure
    async def get_year_id(self,record):
        """Get or create an year entry in the database."""
        session = get_session()
        try:
            async with session.begin():
                # Check for existing _year entry
                result = await session.execute(select(years_table)
                    .where(
                        years_table.years == record.get("syllabus_effective_from")
                    )
                )
                existing = result.scalar_one_or_none()
                if existing:
                    year_id = existing.id
                else:
                    new_entry = years_table(
                        years=record.get("syllabus_effective_from")
                    )
                    session.add(new_entry)
                    await session.flush()  # To get the ID before commit
                    year_id = new_entry.id
                await session.commit()
                return year_id
        except OperationalError as e:
            logger.error(f"Database operation failed in get_year_id: {e}")
            await session.rollback()
        except Exception as e:
            logger.error(f"Unexpected error occurred in get_year_id: {e}")
            await session.rollback()
        finally:
            await session.close()

    @retry_on_failure
    async def get_academic_year(self,request: file_request,year_id):
        """Get or create an academic year entry in the database."""
        session = get_session()
        try:
            async with session.begin():
                # Check for existing academic_year entry
                result = await session.execute(select(academic_years)
                    .where(
                        academic_years.year_id == year_id,
                    )
                )
                # existing = result.scalar_one_or_none()
                existing = result.scalars().first()

                if existing:
                    academic_year_id = existing.id
                else:
                    new_entry = academic_years(
                        year_id=year_id,
                    )
                    session.add(new_entry)
                    await session.flush()  # To get the ID before commit
                    academic_year_id = new_entry.id

                await session.commit()
                return academic_year_id
        except OperationalError as e:
            logger.error(f"Database operation failed in get_academic_year: {e}")
            await session.rollback()
        except Exception as e:
            logger.error(f"Unexpected error occurred in get_academic_year: {e}")
            await session.rollback()
        finally:
            await session.close()

    async def get_semester_id(self,all_data, academic_year_id):
        """Get or create a semester entry in the database."""
        session = get_session()
        try:
            try:
                semester_number = int(all_data["semester"])
            except:
                semester_number = 0
            result_sem = await session.execute(
                text("SELECT id FROM cs_locf.semesters WHERE semester_number = :semester_number AND academic_year_id = :academic_year_id"),{"semester_number": semester_number, "academic_year_id": academic_year_id})
            semester = result_sem.fetchone()
            if semester:
                return semester.id
            else:
                # Determine if semester is odd or even
                semester_type = "odd" if semester_number % 2 != 0 else "even"
                sem_data = semesters(
                    name=f"Semester {all_data['semester']}",
                    semester_number=semester_number,
                    academic_year_id=academic_year_id,
                    year_number=all_data['year'],
                    semester_type = semester_type,
                    is_active=1
                )
                session.add(sem_data)
                await session.flush()
                await session.commit()
                return sem_data.id
        except Exception as e:
            await session.rollback()
            logger.error(f"An error occurred in get sem id: {e}")
            raise
        finally:
            await session.close()

    @retry_on_failure
    async def add_course_data(self, request: file_request, record, file_upload_id, semester_id, sub_id, year_id):
        session = get_session()
        try:
            if not record:
                logger.error("Record is None. Cannot proceed with course data insertion.")
                return "Invalid Record"

            extracted_data = json.dumps(record)
            co_mapping = json.dumps(record.get("mapping_with_programme_outcomes") or None)
            learning_outcomes = json.dumps(record.get("learning_objectives") or None)
            prerequisites = json.dumps(record.get("prerequisites") or None)            
            def safe_get(d: dict, *keys, default=None):
                """Safely get nested dictionary values."""
                for key in keys:
                    if not isinstance(d, dict):
                        return default
                    d = d.get(key, default)
                return d

            def extract_percentage(value):
                if isinstance(value, str) and value.endswith('%'):
                    try:
                        return int(value.replace('%', '').strip())
                    except ValueError:
                        return None
                return value

            code = safe_get(record, "subject_details", "subject_code")
            credits = safe_get(record, "subject_details", "credits")
            instruction_hours = safe_get(record, "subject_details", "instruction_hours")
            theory = extract_percentage(safe_get(record, "theory_vs_problems_ratio", "theory"))
            problems = extract_percentage(safe_get(record, "theory_vs_problems_ratio", "problems"))
            course_type = safe_get(record, "course", "type", default="None")

            if course_type not in ["core", "elective", "lab", "None"]:
                course_type = "None"

            async with session.begin():
                result = await session.execute(
                    select(courses).where(
                        courses.year_id == year_id,
                        courses.course_name_id == sub_id,
                        courses.program_id == request.program_id
                    )
                )
                existing = result.scalar_one_or_none()
                if existing:
                    return "Duplicate"

                data = courses(
                    code=code,
                    course_type=course_type,
                    credits=credits,
                    instruction_hours=instruction_hours,
                    theory_ratio=theory,
                    problems_ratio=problems,
                    total_hours=record.get("total_hours"),
                    year_id=year_id,
                    course_name_id=sub_id,
                    co_mapping=co_mapping,
                    extracted_data=extracted_data,
                    program_id=request.program_id,
                    learning_outcomes=learning_outcomes,
                    prerequisites=prerequisites,
                    file_upload_id=file_upload_id,
                    semester_id=semester_id,
                    syllabus_file_url=request.file_path,
                    is_active=1
                )

                session.add(data)
                await session.flush()

                course_id = data.id
                await session.commit()
                logger.info(f"Course data added successfully with ID: {course_id}")
                return course_id

        except OperationalError as e:
            logger.error(f"Database operation failed in add_course_data: {e}")
            await session.rollback()
        except Exception as e:
            logger.error(f"Database operation failed in add_course_data: {e}")
            await session.rollback()
        finally:
            await session.close()



    @retry_on_failure
    async def get_sub_id(self,record,request:file_request):
        """Get or create an subject entry in the database."""
        session = get_session()
        try:
            async with session.begin():
                # Check for existing subject entry
                result = await session.execute(select(Subjects)
                    .where(Subjects.s_name ==record.get("course", {}).get("title", None)))
                existing = result.scalar_one_or_none()
                if existing:
                    sub_id = existing.id
                else:
                    new_entry = Subjects(s_name=record.get("course", {}).get("title", None)
                        )
                    session.add(new_entry)
                    await session.flush()
                    sub_id = new_entry.id
                await session.commit()
                return sub_id
        except OperationalError as e:
            logger.error(f"Database operation failed in get_subject_id: {e}")
            await session.rollback()
        except Exception as e:
            logger.error(f"Unexpected error occurred in get_subject_id: {e}")
            await session.rollback()
        finally:
            await session.close()

    

